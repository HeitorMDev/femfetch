#!/usr/bin/env bash
# femfetch main script
# =====================
# This is the main entry point for femfetch.
# Loads configuration, libraries, and renders ASCII + system info + optional animations.

# -----------------------------
# Load paths
# -----------------------------
source "/usr/share/femfetch/paths.sh"
# `paths.sh` centralizes all paths for configs, data, frames, etc.

# -----------------------------
# Load configuration if exists
# -----------------------------

[[ -n "$CONFIG_DIR" ]] && source "$CONFIG_DIR/femfetch.conf"

# -----------------------------
# Defaults
# -----------------------------
PADDING=${PADDING:-4}         # Default horizontal padding
SKIPPING_LINES=0              # Tracks how many lines we already printed
version="femfetch 0.9b"      # Default version

# -----------------------------
# Load helper libraries
# -----------------------------

source "/usr/share/femfetch/lib/layout.sh"         # Layout helpers (padding, width)
source "/usr/share/femfetch/lib/femfetch-info.sh"     # Functions that collect system info
source "/usr/share/femfetch/lib/render.sh"         # Rendering functions

# -----------------------------
# Colors
# -----------------------------
C_RESET="\e[0m"
case "$PALETTE" in
    standard)
        C_TITLE="\e[1;34m"; C_LABEL="\e[0;36m"; C_VALUE="\e[1;37m"; C_ACCENT="\e[1;36m"
        ;;
    tech)
        C_TITLE="\e[1;36m"; C_LABEL="\e[0;37m"; C_VALUE="\e[1;37m"; C_ACCENT="\e[1;34m"
        ;;
    nature)
        C_TITLE="\e[1;32m"; C_LABEL="\e[0;33m"; C_VALUE="\e[1;37m"; C_ACCENT="\e[0;32m"
        ;;
    warm)
        C_TITLE="\e[1;31m"; C_LABEL="\e[0;33m"; C_VALUE="\e[1;37m"; C_ACCENT="\e[1;33m"
        ;;
    cyber)
        C_TITLE="\e[1;35m"; C_LABEL="\e[0;34m"; C_VALUE="\e[1;37m"; C_ACCENT="\e[0;35m"
        ;;
    clean)
        C_TITLE="\e[1;37m"; C_LABEL="\e[0;37m"; C_VALUE="\e[1;30m"; C_ACCENT="\e[1;36m"
        ;;
    dark)
        C_TITLE="\e[1;30m"; C_LABEL="\e[0;37m"; C_VALUE="\e[1;37m"; C_ACCENT="\e[0;36m"
        ;;
    *)
        C_TITLE="\e[1;31m"; C_LABEL="\e[1;32m"; C_VALUE="\e[1;34m"; C_ACCENT="\e[1;37m"
        ;;
esac

# -----------------------------
# Box characters (borders)
# -----------------------------
TL="┌"; TR="┐"; BL="└"; BR="┘"; H="─"; V="│"

# -----------------------------
# Flags for modules to show
# -----------------------------
declare -A SHOW
# Initialize all modules as hidden
for mod in OS Host Kernel Uptime Packages Shell Display WM Theme Icons Font Cursor Terminal CPU GPU Memory Swap Disk "Local IP" Locale; do
    SHOW["$mod"]=0
done
# Enable modules from config
for mod in "${SHOW_MODULES[@]}"; do
    SHOW["$mod"]=1
done

# -----------------------------
# Layout setup
# -----------------------------
init_layout              # Calculates INFO_COL based on ASCII art width
: "${INFO_COL:=0}"       # Fallback to 0 if not set
: "${SKIPPING_LINES:=0}" # Reset skipped lines counter

clear                    # Clear terminal
printf '%s\n' "${LEFT_RENDER[@]}"   # Print ASCII art (left)
((SKIPPING_LINES += ${#LEFT_RENDER[@]}))

# -----------------------------
# Header (figlet)
# -----------------------------
header_file="$DATA_DIR/femfetch_ascii.txt"
declare -a HEADER_LINES=()

if [[ ${SHOW_HEADER:-0} == 1 ]]; then
    if [[ "${ITALIC_HEADER:-no}" == "yes" ]]; then
        mapfile -t HEADER_LINES < <(
            figlet -w 999 -f smslant "${CUSTOM_HEADER:-$version}" 2>/dev/null \
            || echo "$version"
        )
    else
        mapfile -t HEADER_LINES < <(
            figlet -w 999 "${CUSTOM_HEADER:-$version}" 2>/dev/null \
            || echo "$version"
        )
    fi
fi
for line in "${HEADER_LINES[@]}"; do
    tput cup "$SKIPPING_LINES" "$INFO_COL"
    printf "%b%s%b" "$C_TITLE" "$line" "$C_RESET"
    ((SKIPPING_LINES++))
done


((SKIPPING_LINES++)) # extra spacing

# -----------------------------
# User@Host
# -----------------------------
USER_LINE=$(echo "$(whoami)@$(echo $HOSTNAME)")
print_user_host "$SKIPPING_LINES" "$INFO_COL" "$USER_LINE"
((SKIPPING_LINES++))

# -----------------------------
# Collect system info
# -----------------------------
declare -A info_values
[[ ${SHOW[OS]} == 1 ]] && info_values[OS]=$(info_os)
[[ ${SHOW[Host]} == 1 ]] && info_values[Host]=$(info_host)
[[ ${SHOW[Kernel]} == 1 ]] && info_values[Kernel]=$(info_kernel)
[[ ${SHOW[Uptime]} == 1 ]] && info_values[Uptime]=$(info_uptime)
[[ ${SHOW[Packages]} == 1 ]] && info_values[Packages]=$(info_packages)
[[ ${SHOW[Shell]} == 1 ]] && info_values[Shell]=$(info_shell)
[[ ${SHOW[CPU]} == 1 ]] && info_values[CPU]=$(info_cpu)
[[ ${SHOW[GPU]} == 1 ]] && info_values[GPU]=$(info_gpu)
[[ ${SHOW[Memory]} == 1 ]] && info_values[Memory]=$(info_memory)
[[ ${SHOW[Swap]} == 1 ]] && info_values[Swap]=$(info_swap)
[[ ${SHOW[Disk]} == 1 ]] && info_values[Disk]=$(info_disk)
[[ ${SHOW[Display]} == 1 ]] && info_values[Display]=$(info_display)
[[ ${SHOW[WM]} == 1 ]] && info_values[WM]=$(info_wm)
[[ ${SHOW[Theme]} == 1 ]] && info_values[Theme]=$(info_theme)
[[ ${SHOW[Icons]} == 1 ]] && info_values[Icons]=$(info_icons)
[[ ${SHOW[Cursor]} == 1 ]] && info_values[Cursor]=$(info_cursor)
[[ ${SHOW[Font]} == 1 ]] && info_values[Font]=$(info_font)
[[ ${SHOW[Terminal]} == 1 ]] && info_values[Terminal]=$(info_terminal)
[[ ${SHOW["Local IP"]} == 1 ]] && info_values["Local IP"]=$(info_local_ip)
[[ ${SHOW[Locale]} == 1 ]] && info_values[Locale]=$(info_locale)

# -----------------------------
# Calculate max label width
# -----------------------------

declare -a INFO_SOFTWARE=(
    "OS" "Host" "Kernel" "Uptime" "Packages" "Shell"
    "Display" "WM" "Theme" "Icons" "Cursor" "Font" "Terminal"
    "Local IP" "Locale"
)

# ---------------- Hardware ----------------
declare -a INFO_HARDWARE=(
    "CPU" "GPU" "Memory" "Swap" "Disk"
)


max_label=0
for label in "${!info_values[@]}"; do
    (( ${#label} > max_label )) && max_label=${#label}
done

if [[ "$SPACE_LABELINFO" == "yes" ]]; then 
    VALUE_START_COL=$((INFO_COL + max_label + PADDING))
else
    VALUE_START_COL=$((INFO_COL + 2))
fi

# -----------------------------
# Print info groups
# -----------------------------
[[ "$SEPARATOR_GROUP" == "yes" ]] && print_separator INFO_SOFTWARE
print_group INFO_SOFTWARE "$SKIPPING_LINES"
used=$(print_group_n INFO_SOFTWARE "$SKIPPING_LINES")
((SKIPPING_LINES += used))
[[ "$SEPARATOR_GROUP" == "yes" ]] && print_separator INFO_SOFTWARE
print_group INFO_HARDWARE "$SKIPPING_LINES"
used=$(print_group_n INFO_HARDWARE "$SKIPPING_LINES")
((SKIPPING_LINES += used))

# -----------------------------
# GIF / ASCII rendering
# -----------------------------
if [[ "$ANIMATION" == "yes" ]]; then
    DISTRO=$(bash "$LIB_DIR/logoLoader.sh")      # Detect distro
    GIF_FINAL="$DISTRO_GIF_DIR/$DISTRO"
    bash "$DATA_DIR/AsciiGIF/asgif" "$GIF_FINAL" &  # Launch GIF render
    bash "$DATA_DIR/animKiller.sh" "$$" "$!" &              # Kill previous animation
else
    DISTRO=$(bash "$LIB_DIR/logoLoader.sh")
    python3 "$DATA_DIR/AsciiGIF/renderJ.py" "$DATA_DIR/ascii/${DISTRO}.json" "$GIF_HEIGHT" "$GIF_WIDTH" --flat "$C_LABEL"
fi

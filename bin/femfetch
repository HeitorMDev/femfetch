#!/usr/bin/env bash
# femfetch main script
# =====================
# This is the main entry point for femfetch.
# Loads configuration, libraries, and renders ASCII + system info + optional animations.

# -----------------------------
# Load paths
# -----------------------------
source "$(dirname "$(readlink -f "$0")")/paths.sh"
# `paths.sh` centralizes all paths for configs, data, frames, etc.

# -----------------------------
# Load configuration if exists
# -----------------------------
CONF="$CONFIG_DIR/femfetch.conf"
[[ -f "$CONF" ]] && source "$CONF"

# -----------------------------
# Load helper libraries
# -----------------------------
source "$LIB_DIR/render.sh"         # Rendering functions
source "$LIB_DIR/layout.sh"         # Layout helpers (padding, width)
source "$LIB_DIR/femfetch-info"     # Functions that collect system info

# -----------------------------
# Defaults
# -----------------------------
PADDING=${PADDING:-4}         # Default horizontal padding
SKIPPING_LINES=0              # Tracks how many lines we already printed
version="femfetch 0.9b"      # Default version

# -----------------------------
# Colors
# -----------------------------
C_RESET="\e[0m"
case "$PALETTE" in
    standard)
        C_TITLE="\e[1;34m"; C_LABEL="\e[0;36m"; C_VALUE="\e[1;37m"; C_ACCENT="\e[1;36m"
        ;;
    tech)
        C_TITLE="\e[1;36m"; C_LABEL="\e[0;37m"; C_VALUE="\e[1;37m"; C_ACCENT="\e[1;34m"
        ;;
    nature)
        C_TITLE="\e[1;32m"; C_LABEL="\e[0;33m"; C_VALUE="\e[1;37m"; C_ACCENT="\e[0;32m"
        ;;
    warm)
        C_TITLE="\e[1;31m"; C_LABEL="\e[0;33m"; C_VALUE="\e[1;37m"; C_ACCENT="\e[1;33m"
        ;;
    cyber)
        C_TITLE="\e[1;35m"; C_LABEL="\e[0;34m"; C_VALUE="\e[1;37m"; C_ACCENT="\e[0;35m"
        ;;
    clean)
        C_TITLE="\e[1;37m"; C_LABEL="\e[0;37m"; C_VALUE="\e[1;30m"; C_ACCENT="\e[1;36m"
        ;;
    dark)
        C_TITLE="\e[1;30m"; C_LABEL="\e[0;37m"; C_VALUE="\e[1;37m"; C_ACCENT="\e[0;36m"
        ;;
    *)
        C_TITLE="\e[1;31m"; C_LABEL="\e[1;32m"; C_VALUE="\e[1;34m"; C_ACCENT="\e[1;37m"
        ;;
esac

# -----------------------------
# Box characters (borders)
# -----------------------------
TL="┌"; TR="┐"; BL="└"; BR="┘"; H="─"; V="│"

# -----------------------------
# Flags for modules to show
# -----------------------------
declare -A SHOW
# Initialize all modules as hidden
for mod in OS Host Kernel Uptime Packages Shell Display WM Theme Icons Font Cursor Terminal CPU GPU Memory Swap Disk "Local IP" Locale; do
    SHOW["$mod"]=0
done
# Enable modules from config
for mod in "${SHOW_MODULES[@]}"; do
    SHOW["$mod"]=1
done

# -----------------------------
# Layout setup
# -----------------------------
init_layout              # Calculates INFO_COL based on ASCII art width
: "${INFO_COL:=0}"       # Fallback to 0 if not set
: "${SKIPPING_LINES:=0}" # Reset skipped lines counter

clear                    # Clear terminal
printf '%s\n' "${LEFT_RENDER[@]}"   # Print ASCII art (left)
((SKIPPING_LINES += ${#LEFT_RENDER[@]}))

# -----------------------------
# Header (figlet)
# -----------------------------
if [[ ${SHOW_HEADER:-0} == 1 ]]; then
    FONT="${ITALIC_HEADER:-no}" 
    FIG_HEADER=$(figlet -w 999 ${FONT:="sm"} "${CUSTOM_HEADER:-$version}" 2>/dev/null || echo "$version")
    while read -r line; do
        ((SKIPPING_LINES++))
        # Align header left or right
        [[ "${ALIGN_HEADER:-right}" == "right" ]] && tput cup "$SKIPPING_LINES" "$INFO_COL" || tput cup "$SKIPPING_LINES" 0
        printf "%b%s%b\n" "$C_TITLE" "$line" "$C_RESET"
    done <<< "$FIG_HEADER"
fi

((SKIPPING_LINES++)) # extra spacing

# -----------------------------
# User@Host
# -----------------------------
USER_LINE=("$C_ACCENT $(whoami)@$(hostname) $C_RESET")
print_user_host "$SKIPPING_LINES" "$INFO_COL" "$USER_LINE"
((SKIPPING_LINES++))

# -----------------------------
# Collect system info
# -----------------------------
declare -A info_values
[[ ${SHOW[OS]} == 1 ]] && info_values[OS]=$(info_os)
[[ ${SHOW[Host]} == 1 ]] && info_values[Host]=$(info_host)
[[ ${SHOW[Kernel]} == 1 ]] && info_values[Kernel]=$(info_kernel)
[[ ${SHOW[Uptime]} == 1 ]] && info_values[Uptime]=$(info_uptime)
[[ ${SHOW[Packages]} == 1 ]] && info_values[Packages]=$(info_packages)
[[ ${SHOW[Shell]} == 1 ]] && info_values[Shell]=$(info_shell)
[[ ${SHOW[CPU]} == 1 ]] && info_values[CPU]=$(info_cpu)
[[ ${SHOW[GPU]} == 1 ]] && info_values[GPU]=$(info_gpu)
[[ ${SHOW[Memory]} == 1 ]] && info_values[Memory]=$(info_memory)
[[ ${SHOW[Swap]} == 1 ]] && info_values[Swap]=$(info_swap)
[[ ${SHOW[Disk]} == 1 ]] && info_values[Disk]=$(info_disk)
[[ ${SHOW[Display]} == 1 ]] && info_values[Display]=$(info_display)
[[ ${SHOW[WM]} == 1 ]] && info_values[WM]=$(info_wm)
[[ ${SHOW[Theme]} == 1 ]] && info_values[Theme]=$(info_theme)
[[ ${SHOW[Icons]} == 1 ]] && info_values[Icons]=$(info_icons)
[[ ${SHOW[Cursor]} == 1 ]] && info_values[Cursor]=$(info_cursor)
[[ ${SHOW[Font]} == 1 ]] && info_values[Font]=$(info_font)
[[ ${SHOW[Terminal]} == 1 ]] && info_values[Terminal]=$(info_terminal)
[[ ${SHOW["Local IP"]} == 1 ]] && info_values["Local IP"]=$(info_local_ip)
[[ ${SHOW[Locale]} == 1 ]] && info_values[Locale]=$(info_locale)

# -----------------------------
# Calculate max label width
# -----------------------------
max_label=0
for label in "${!info_values[@]}"; do
    (( ${#label} > max_label )) && max_label=${#label}
done

if [[ "$SPACE_LABELINFO" == "yes" ]]; then 
    VALUE_START_COL=$((INFO_COL + max_label + PADDING))
else
    VALUE_START_COL=$((INFO_COL + 2))
fi

# -----------------------------
# Print info groups
# -----------------------------
print_separator "$SEPARATOR_GROUP"
print_group INFO_SOFTWARE "$SKIPPING_LINES"
used=$(print_group_n INFO_SOFTWARE "$SKIPPING_LINES")
((SKIPPING_LINES += used + 1))
print_group INFO_HARDWARE "$SKIPPING_LINES"
used=$(print_group_n INFO_HARDWARE "$SKIPPING_LINES")
((SKIPPING_LINES += used + 1))

# -----------------------------
# GIF / ASCII rendering
# -----------------------------
if [[ "$ANIMATION" == "yes" ]]; then
    DISTRO=$(bash "$LIB_DIR/logoLoader.sh")      # Detect distro
    GIF_FINAL="$DISTRO_GIF_DIR/$DISTRO"
    bash "$LIB_DIR/animKiller.sh" &              # Kill previous animation
    bash "$DATA_DIR/AsciiGIF/asgif" "$GIF_FINAL" &  # Launch GIF render
else
    DISTRO=$(bash "$LIB_DIR/logoLoader.sh")
    python3 "$DATA_DIR/AsciiGIF/renderJ.py" "$DATA_DIR/ascii/${DISTRO}.json" "$GIF_HEIGHT" "$GIF_WIDTH" --flat "$C_LABEL"
fi
